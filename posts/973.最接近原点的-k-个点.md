---
title: 973.最接近原点的-k-个点
date: "2020-11-09"
topic: [每日一题, 数组, 排序, 堆]
---

# 思路一

直观解法。
- 遍历数组，将距离和原坐标存储到另一数组B中。
- 对数组B从小到大排序
- 取前K个元素遍历返回原坐标

时间复杂度：$O(NlogN)$
空间复杂度：$O(N)$

``` js
/**
 * @param {number[][]} points
 * @param {number} K
 * @return {number[][]}
 */
var kClosest = function(points, K) {
    const distances= points.map(([x, y], index) => ({
        value: x * x + y * y,
        index
    })).sort((a, b) => a.value - b.value);
    return distances.slice(0, K).map(({index}) => points[index]);
};
```

# 思路二

基于快排求解，求前K个元素，只需从大到小排到前K个元素。利用快排的分治思想。

``` js
/**
 * @param {number[][]} points
 * @param {number} K
 * @return {number[][]}
 */
var kClosest = function (points, K) {
  function distance([x, y]) {
    return x * x + y * y;
  }

  function quickSort(l, r) {
    if (l >= r) {
      return l;
    }

    const p = partition(l, r);
    if (p + 1 === K) return p;
    if (p + 1 < K) return quickSort(p + 1, r);
    else return quickSort(l, p - 1);
  }

  function partition(l, r) {
    const v = distance(points[l]);
    let i = l + 1;
    let j = l;

    while (i <= r) {
      if (distance(points[i]) <= v) {
        j++;
        [points[j], points[i]] = [points[i], points[j]];
      }
      i++;
    }
    [points[j], points[l]] = [points[l], points[j]];
    return j;
  }

  quickSort(0, points.length - 1);
  return points.slice(0, K);
};
```


# 扩展

类似题目：215. 数组中的第K个最大元素