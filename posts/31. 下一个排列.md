---
title: 31. 下一个排列
date: "2020-11-10"
topic: [每日一题, 数组]
---

# 问题描述

实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。


`1,2,3 → 1,3,2`

`3,2,1 → 1,2,3`

`1,1,5 → 1,5,1`



来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/next-permutation

著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。


# 解题思路

## 我的首次解法

- 确定高位较小值。从右向左寻找高位较小，低位较大的值。想象成山丘，右侧是山坡，左侧是山谷。
- 确定低位较大值。左侧是递减序列，找到最低位的较大值。在这可以用一个Map或者Array存储number2Index。number只有0-9十种可能性，index取最远值。
- 替换较小值和较大值，替换后左侧是递减序列
- 反转，将左侧递减序列前后替换位置，转换为递增序列

``` js
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var nextPermutation = function(nums) {
    const index = findIndex(nums);
    sort(nums, index + 1);
    return nums;
};

function findIndex (nums) {
    const numIndex = new Map();
    let i = nums.length -1;

    while (i >= 0) {
        const prev = nums[i];
        const next = nums[i + 1];
        if (prev < next) {
            let num = prev + 1;
            while (num <= next) {
                if (numIndex.has(num)) {
                    const index = numIndex.get(num);
                    [nums[i], nums[index]] = [nums[index], nums[i]];
                    break;
                }
                num++;
            }
            break;
        } else {
            if (!numIndex.has(prev)) {
                numIndex.set(prev, i);
            }
            i--;
        }
    }

    return i;
}

function sort (nums, start) {
    let l = start;
    let r = nums.length - 1;

    while (l < r) {
        [nums[l], nums[r]] = [nums[r], nums[l]];
        l++;
        r--;
    }
}
```

## 官方题解

官方题解思路大体一致，只不过并没有缓存记录number2Index，而是直接用二次遍历确定较大值。

``` js
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var nextPermutation = function(nums) {
    const len = nums.length;
    let i = len - 2;
    while(i >= 0 && nums[i] >= nums[i + 1]) i--;
    if (i >= 0) {
        let j = len - 1;
        while(nums[j] <= nums[i]) j--;
        [nums[i], nums[j]] = [nums[j], nums[i]];
    }
    let l = i + 1, r = len - 1;
    while(l < r) {
        [nums[l], nums[r]] = [nums[r], nums[l]];
        l++;
        r--;
    }
};
```